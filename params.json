{"name":"Cryptico","tagline":"An easy-to-use encryption system utilizing RSA and AES for javascript.","body":"## Overview\r\n\r\n### Generating an RSA key pair & public key string\r\n\r\nSam wants to send Matt an encrypted message.  In order to do this, he first needs Matt's public key string.  A public key pair can be generated for Matt like this:\r\n\r\n```javascript\r\n// The passphrase used to repeatably generate this RSA key.\r\nvar PassPhrase = \"The Moon is a Harsh Mistress.\"; \r\n\r\n// The length of the RSA key, in bits.\r\nvar Bits = 1024; \r\n\r\nvar MattsRSAkey = cryptico.generateRSAKey(PassPhrase, Bits);\r\n```\r\n\r\nMatt's public key string can then be generated like this:\r\n\r\n```javascript\r\nvar MattsPublicKeyString = cryptico.publicKeyString(MattsRSAkey);       \r\n```\r\n\r\nand looks like this:\r\n        \r\n    uXjrkGqe5WuS7zsTg6Z9DuS8cXLFz38ue+xrFzxrcQJCXtVccCoUFP2qH/AQ\r\n    4qMvxxvqkSYBpRm1R5a4/NdQ5ei8sE8gfZEq7dlcR+gOSv3nnS4/CX1n5Z5m\r\n    8bvFPF0lSZnYQ23xlyjXTaNacmV0IuZbqWd4j9LfdAKq5dvDaoE=\r\n\r\n### Encrypting a message\r\n\r\nMatt emails Sam his public key string.  Now Sam can encrypt a message for Matt:\r\n\r\n```javascript\r\nvar PlainText = \"Matt, I need you to help me with my Starcraft strategy.\";\r\n\r\nvar EncryptionResult = cryptico.encrypt(PlainText, MattsPublicKeyString);\r\n```\r\n\r\n`EncryptionResult.cipher` is the encrypted message, and looks like this:\r\n\r\n    OOHoAlfm6Viyl7afkUVRoYQv24AfdLnxaay5GjcqpxvEK+dph5kUFZEZIFKo\r\n    vVoHoZbtUMekSbMqHQr3wNNpvcNWr4E3DgNLfMZQA1pCAUVmPjNM1ZQmrkKY\r\n    HPKvkhmVKaBiYAJGoO/YiFfKnaylLpKOYJZctkZc4wflZcEEqqg=?cJPt71I\r\n    HcU5c2LgqGXQKcx2BaAbm25Q2Ku94c933LX5MObL9qbTJEVEv29U0C3gIqcd\r\n    qwMV6nl33GtHjyRdHx5fZcon21glUKIbE9P71NwQ=\r\n\r\n### Decrypting a message\r\n    \r\nSam sends his encrypted message to Matt. The message can be decrypted like this:\r\n    \r\n```javascript\r\nvar CipherText = \"OOHoAlfm6Viyl7afkUVRoYQv24AfdLnxaay5GjcqpxvEK+dph5kUFZEZIFKo \\\r\n                  vVoHoZbtUMekSbMqHQr3wNNpvcNWr4E3DgNLfMZQA1pCAUVmPjNM1ZQmrkKY \\\r\n                  HPKvkhmVKaBiYAJGoO/YiFfKnaylLpKOYJZctkZc4wflZcEEqqg=?cJPt71I \\\r\n                  HcU5c2LgqGXQKcx2BaAbm25Q2Ku94c933LX5MObL9qbTJEVEv29U0C3gIqcd \\\r\n                  qwMV6nl33GtHjyRdHx5fZcon21glUKIbE9P71NwQ=\";\r\n\r\nvar DecryptionResult = cryptico.decrypt(CipherText, MattsRSAkey);\r\n```\r\n\r\nThe decrypted message is in `DecryptionResult.plaintext`.\r\n\r\n### Signatures & Public Key IDs\r\n    \r\nIf Sam's RSA key is provided to the `cryptico.encrypt` function, the message will be signed by him:\r\n    \r\n```javascript\r\nvar PassPhrase = \"There Ain't No Such Thing As A Free Lunch.\"; \r\n\r\nvar SamsRSAkey = cryptico.generateRSAKey(PassPhrase, 1024);\r\n\r\nvar PlainText = \"Matt, I need you to help me with my Starcraft strategy.\";\r\n\r\nvar EncryptionResult = cryptico.encrypt(PlainText, MattsPublicKeyString, SamsRSAkey);\r\n```\r\n\r\nThe public key associated with the signature can be used by Matt to make sure that it was sent by Sam, but there are a lot of characters to examine in the key - it would be easy to make a mistake.  Instead, the public key string associated with the signature can be processed like this:\r\n    \r\n```javascript\r\nvar PublicKeyID = cryptico.publicKeyID(EncryptionResult.publickey);\r\n```\r\n\r\nand `PublicKeyID` would look something like this:\r\n    \r\n    d0bffb0c422dfa3d3d8502040b915248\r\n\r\nThis shorter key ID can be used to uniquely identify Sam's public key more easily if it must be done manually.  Moreover, this key ID can be used by Sam or Matt to make sure they have typed their own passphrases correctly.\r\n    \r\n# API Documentation\r\n\r\n## RSA Keys\r\n\r\n    cryptico.generateRSAKey(passphrase, bitlength)\r\n\r\nGenerates an RSAKey object from a password and bitlength.\r\n\r\n`passphrase`: string from which the RSA key is generated.\r\n\r\n`bitlength`: integer, length of the RSA key (512, 1024, 2048, 4096, 8192).\r\n\r\nReturns an `RSAKey` object.\r\n\r\n    cryptico.publicKeyString(rsakey)\r\n\r\nReturns the public key portion of an RSAKey object in ascii-armored\r\nstring form, which allows it to be used on websites and in text files\r\nwithout fear of corrupting the public key.\r\n\r\n`rsakey`: An `RSAKey` object.\r\n\r\nReturns an ascii-armored public key string.\r\n    \r\n    cryptico.publicKeyID(publicKeyString)\r\n\r\nReturns an MD5 sum of a `publicKeyString` for easier identification.\r\n\r\n`publicKeyString`: a public key in ascii-armored string form, as generated by the `cryptico.publicKeyString` function.\r\n\r\nReturns an MD5 sum of the public key string.   \r\n\r\n## Encryption\r\n\r\n    cryptico.encrypt(plaintext, publicKeyString, signingKey)\r\n\r\nEncrypts a string with the provided public key. Optionally signs the encrypted string with an RSAKey object.\r\n\r\n`plaintext`: the string to be encrypted.\r\n    \r\n`publicKeyString`: The public key string of the recipient.\r\n    \r\n`signingKey`: the `RSAKey` object of the sender.\r\n    \r\nReturns: `status`, `cipher`\r\n\r\n`status`: \"success\" if encryption succeeded, \"failure\" if it failed.\r\n    \r\n`cipher`: An ascii-armored encrypted message string, optionally signed.\r\n\r\n## Decryption\r\n\r\n    cryptico.decrypt(ciphertext, key)\r\n\r\nDecrypts an encrypted message with the recipient's RSAKey and verifies the signature, if any.\r\n\r\n`ciphertext`: The encrypted message to be decrypted.\r\n    \r\n`key`: The `RSAKey` object of the recipient.\r\n\r\nReturns: `status`, `plaintext`, `signature`, `publicKeyString`\r\n\r\n`status`: \"success\" if decryption succeeded, \"failure\" if it failed. **Does not reflect the status of the signature verification.**\r\n\r\n`plaintext`: The decrypted message.\r\n    \r\n`signature`: \"unsigned\" if there was no signature, \"verified\" if it is signed and valid, **\"forged\" if the signature fails verification**.\r\n\r\n`publicKeyString`: public key string of the signature (presumably the sender). **Returned even if the signature appears to be forged**.\r\n\r\n# Encryption Technical Documentation\r\n\r\n## Key generation\r\n\r\nA hash is generated of the user's passphrase using the SHA256 algorithm found at <a href=\"http://www.webtoolkit.info/javascript-sha256.html\">webtoolkit.info</a>. This hash is used to seed <a href=\"http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html\">David Bau's seedable random number generator</a>. A (seeded) random RSA key is generated with <a href=\"http://www-cs-students.stanford.edu/~tjw/jsbn/\">Tom Wu's RSA key generator</a> with 3 as a hard-coded public exponent.\r\n\r\n## Encryption\r\n\r\nA 32-byte AES key is generated with <a href=\"http://www-cs-students.stanford.edu/~tjw/jsbn/\">Tom Wu's random number generator</a>. The plaintext message is converted to a byte string and padded with zeros to 16 bytes round.  An initialization vector is created with <a href=\"http://www-cs-students.stanford.edu/~tjw/jsbn/\">Tom Wu's random number generator</a>. The AES key is expanded and the plaintext message is encrypted with the Cipher-block chaining mode using the <a href=\"http://point-at-infinity.org/jsaes/\">jsaes</a> library. The AES key is encrypted with the recipient's public key using <a href=\"http://www-cs-students.stanford.edu/~tjw/jsbn/\">Tom Wu's RSA encryption library</a>.\r\n\r\nThe encrypted AES key and encrypted message are ascii-armored and concatenated with the \"?\" character as a delimiter.  As an example, here is the result of the phrase \"Matt, I need you to help me with my Starcraft strategy.\" encrypted with\r\nthe passphrase \"The Moon is a Harsh Mistress.\" used to generate the 1024-bit public key:\r\n\r\n    EuvU2Ov3gpgM9B1I3VzEgxaAVO/Iy85NARUFZb/h+HrOP72degP0L1fWiHO3\r\n    RDm5+kWRaV6oZsn91juJ0L+hrP6BDwlIza9x9DBMEsg3PnOHJENG63RXbu0q\r\n    PZd2xDJY70i44sufNqHZ0mui9OdNIeE8FvzEOzMtFGCqDx1Z48s=?K3lOtQC\r\n    2w+emoR4W3yvAaslSzTj/ZZIkOu3MNTW8y/OX0OxTKfpsaI6zX6XYrM0MpPr\r\n    uw7on1N6VUMpNQO8KUVYl4clquaibKs0marXPFH4=\r\n\r\n## Signing\r\n\r\nWhen signing the encrypted message, two more pieces of information are attached to the cipher text.  The first is the ascii-armored RSA public key of the sender. The second piece of information concatenated with the cipher text is\r\nthe signature itself, which is generated with the <a href=\"http://www9.atwiki.jp/kurushima/pub/jsrsa/\">rsa-sign extension by Kenji Urushima</a>, along with the SHA256 algorithm found at <a href=\"http://www.webtoolkit.info/javascript-sha256.html\">webtoolkit.info</a>. These two pieces of code are also used when verifying the signature.\r\n\r\nThe signature is concatenated with the public key with the string\r\n`::52cee64bb3a38f6403386519a39ac91c::` used as the delimiter between the\r\nplaintext, the public key of the sender, and the signature:\r\n\r\n    plaintext\r\n    ::52cee64bb3a38f6403386519a39ac91c::\r\n    public key of sender\r\n    ::52cee64bb3a38f6403386519a39ac91c::\r\n    signature\r\n\r\nThis concatenated block is then encrypted with CBC AES and concatenated with the\r\nencrypted AES key to form the complete encrypted message.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}